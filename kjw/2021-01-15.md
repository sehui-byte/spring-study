# Spring MVC -  결합과 의존성은 뭘까?


<hr/>

&nbsp;&nbsp;&nbsp;&nbsp;W : Spring에서는 기존 Model2 + MVC의 환경설정파일과 Spring의 환경설정 파일을 체크해서 추상적인 Spring 컨테이너 구동 원리를 이해하고 싶다.

## 학습목표
&nbsp;&nbsp;&nbsp;&nbsp;- Spring의 결합, 의존성에 대해서 파악하기
<hr/>

&nbsp;&nbsp;&nbsp;&nbsp;오늘은 Spring에 직접적인 이야기는 아니지만, 그간 항상 궁금했던 내용을 짚어보면서 Spring이 왜 결합이 약해지며 의존관계가 약해지는 것에 대해 알아보도록 하겠다.  

&nbsp;&nbsp;&nbsp;&nbsp;나는 아직까지 기초 개념이 부족하여 자리잡지 않은 것들이 몇 가지 있다. 그 중 대표적인게 인터페이스에 관한 내용이다. 인터페이스를 사용하면 결합이 약해진다고 한다. 그렇다고는 하는데, 근본이 없는 내가 보기에는 직접적으로 클래스를 인스턴스해서 사용하는 방식에서 오히려 인터페이스라는 불필요한게 하나 더 늘어난 모양이 되어 어지간히 이해가 되지 않았다. 그런 상태로 인터페이스를 왜 사용하는지도 모르고 있다가 Spring에서 기초 개념을 이해할 때 또다시 결합과 의존성이 나오면서 이 개념을 명확하게 이해하지 않으면 앞으로 곤란해지겠다는 생각에 인터넷을 뒤져보았다.  
&nbsp;&nbsp;&nbsp;&nbsp;클래스와의 결합에 대해서는 내가 지금까지 공부했던 것은 약 3가지 이다. 첫째가 클래스 간에 new 키워드로 결합을 하는 방법과, 클래스와 인스턴스로 결합을 하는 방법, 그리고 마지막으로 Spring에서 컨테이너를 사용해서 결합하는 방법이다.

>> 1. 클래스 간에 new 인스턴스
>> 2. 클래스 - 인터페이스 - 클래스
>> 3. Spring 컨테이너를 이용한 주입

&nbsp;&nbsp;&nbsp;&nbsp;클래스간에 new 인스턴스로 참조변수를 사용하는 방법은 왜 결합도가 높은지, 의존성이 높은지 이해가 간다. 해당 클래스에서 new 키워드를 통해서 사용하는 방법은 유지보수에는 굉장히 안좋은 방법이다. 코드에 문제가 있어서 수정을 하기 위해서는 무조건 클래스를 수정해야만 하며, 그 클래스의 참조변수를 사용하고 있는 클래스들도 모조리 수정해야만 한다. 가장 직관적이지만, 가장 손이 많이 가는 관계라는건 한번에 이해가 간다.  
&nbsp;&nbsp;&nbsp;&nbsp;다음부터 나를 혼란스럽게 만들었다. 클래스 - 인터페이스 - 클래스로 중간에 인터페이스가 삽입되었다. 인터페이스를 삽입하여 클래스의 연결 중간에 괴상한 개념이 끼어들었는데, 이렇게 함으로 인해서 클래스간에 의존성이 떨어진다고 한다. 한층 더 유지보수가 좋아졌다고 한다.  
&nbsp;&nbsp;&nbsp;&nbsp;나는 이게 이해가 되지 않았다. 그래서 그간 인터페이스의 장점은 하나의 함수를 다른 클래스에서 강제적으로 사용하게 함으로써 통일성과 규칙을 지키게 하는 용도로밖에 이해하지 못했었다. 그리고 조금 더 살펴본 뒤에서야 왜 인터페이스가 클래스간에 의존성을 떨어뜨린다고 하는지 약간이나마 이해할 수 있었다.  
&nbsp;&nbsp;&nbsp;&nbsp;나는 그간 코드로만 관계를 이해하려고 하니까, 당연히 클래스 간에서도 new로 인스턴스를 하고, 사용법은 조금 달라도 인터페이스도 new로 인스턴스를 하니까(물론 인터페이스를 상속받은 구현체지만) 어찌됐든 두 방법 모두 직접 클래스 내부에 new 키워드를 이용해서 사용하는 방법이니까 별반 차이를 느끼지 못했었다.  
&nbsp;&nbsp;&nbsp;&nbsp;하지만 차이는 유연성에 두어야 했다.  
&nbsp;&nbsp;&nbsp;&nbsp;인터페이스를 사용하면 다형성이라는 특징을 가지게 된다. 이게 내가 잘 이애하고 있는지는 잘 모르겠지만 한번 정의하자면, 인터페이스를 상속받은 구현체들을, 하나의 인터페이스 참조변수로 전부 가리킬 수 있는 것이다. 예를 들어 동물은 말하지 않고 울음소리를 낸다. 하지만 울음소리는 각 동물의 개체마다 다르다. 한국식 의성어로 표현하면 개는 멍멍, 고양이는 야옹, 호랑이는 어흥 등등... 울음소리를 가진다는 공통점은 있지만, 울음소리의 구현은 전부 다르다. 인터페이스는 여기서 울음소리를 가리키며, 인터페이스를 상속받은 구현체들은 각 개체들이 가지는 독특한 울음소리를 나타낸다. 이러한 관계는 자바에서 인터페이스의 참조변수가 구현 클래스를 전부다 가리킬 수 있는 다형성으로 나타난다.  

```java
// 동물들이 가지는 울음소리 인터페이스
public interface animal{

    public String howling();

}

public class dog implements animal(){

    // 인터페이스 animal을 구현화한 함수
    @Override
    public String howling(){
            System.out.println("멍멍");
    }
}

public class cat implements animal(){

    // 인터페이스 animal을 구현화한 함수
    @Override
    public String howling(){
            System.out.println("야옹");
    }
}

//이 경우에 animal의 참조변수는 멍멍도 야옹도 출력할 수 있다.

animal aa = new dog();
aa.howling();
// >> 멍멍 출력

animal bb = new cat();
bb.howling();
// >> 야옹 출력
```

&nbsp;&nbsp;&nbsp;&nbsp;이런 관계에서는 인터페이스를 참조하는 다른 클래스를 만들었다고 가정하면, animal의 참조변수는 자신을 구현하는 모든 클래스들을 가리킬 수 있게 되는 것이다. 그리고 그 구현체를 사용하고자 하는 클래스에서 사용할 수 있는 것이다. 이게 내가 지금까지 이해가 안되었다가 공부가 축적되면서 알게된 인터페이스의 장점이며, 이것을 다형성이라고 표현하는 것 같다. 이렇게 되면 확실히 인터페이스는 고정적으로 어떤 개념을 가리키는 것이 아니기 때문에 클래스와 인터페이스의 관계가 느슨하다, 의존성이 낮다고 표현할 수 있을 것 같다.  
&nbsp;&nbsp;&nbsp;&nbsp;Spring은 여기서 아예 new 코드를 없애버렸다. @Autowired 어노테이션을 사용하면 new 키워드를 클래스 내부에서 사용할 일이 없어졌다. 물론 이런 물리적인 부분만이 아니라 XML 파일에 Bean으로 정의하면 자동으로 메모리에 올라가고, 타입이 맞으면 자동으로 맞춰주는 역할도 하기 때문에(주로 VO 클래스가) 훨씬 의존성이 낮아진 것이다.  
&nbsp;&nbsp;&nbsp;&nbsp;이렇게 오늘은 Spring만이 아닌, 그간 이해되지 않았던 인터페이스의 다형성에 대해서도 엮어서 알아보았다. Spring 역시 기본은 자바에서 출발하기 때문에, 결국에 원인을 규명하기 위해서는 자바의 개념을 깊이있기 이해하고 있어야 할것 같다는 생각이 들었다. 아마 다음에 Spring의 의존성 주입을 자바와 관련지어 Reflection에 대해 공부할 날이 있을 것 같다.

<hr/>

_참고문헌_

Spring 학원 교재  
Medium의 Dope님의 게시글 : <https://medium.com/webeveloper/%EC%9E%90%EB%B0%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-6eecbe5d6350>
