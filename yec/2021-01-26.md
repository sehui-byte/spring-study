Day 2 이어서...



# Class 05 어노테이션 기반 AOP

스프링 IoC 를 학습하면서 XML 기반 설정과 어노테이션 기반 설정, 둘을 적절하게 혼합하여 사용하면 XML 설정을 최소화하면서 객체들을 효율적으로 관리할 수 있었다.

스프링 AOP 도 IoC 와 마찬가지로 어노테이션 설정을 지원한다.

**5.1 어노테이션 기반 AOP 설정**

5.1.1 어노테이션 사용을 위한 스프링 설정

AOP 를 어노테이션으로 설정하려면 먼저 스프링 설정 파일에 `<aop:aspectj-autoproxy>` 엘리먼트르 선언해야 한다.

`applicationContext.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                    http://www.springframework.org/schema/beans/spring-beans.xsd
                    http://www.springframework.org/schema/context 
                    http://www.springframework.org/schema/context/spring-context-4.2.xsd
                    http://www.springframework.org/schema/aop
                    http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
						   
	<!-- base-package="com.springbook.biz" 로 지정하면 
			 com.springbook.biz 패키지로 시작하는 모듵 패키지를 스캔 대상에 포함 & 객체 생성한다  -->
	<context:component-scan base-package="com.springbook.biz"></context:component-scan>
	
	<!-- 스프링 컨테이너가 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다. -->
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
</beans>
```

AOP 관련 어노테이션들은 어드바이스 클래스에 설정하며 반드시 어드바이스 객체가 생성되어 있어야 스프링 컨테이너가 처리할 수 있다.

어드바이스 클래스는 반드시 스프링 설정 파일에 <bean> 등록하거나 @Service 어노테이션을 사용하여 컴포넌트가 검색될 수 있도록 해야 한다.

![Untitled](https://user-images.githubusercontent.com/77134124/105853806-70f59380-6029-11eb-84bc-3243b7248800.png)

5.1.2 Pointcut 설정

@Pointcut 을 사용하며, 하나의 Advice 클래스 안에 여러 개의 Pointcut 을 선언할 수 있다. 여러 Pointcut 을 식별하기 위해 식별자가 필요한데, 이때 참조 메소드를 이용한다.

참조 메소드는 구현 로직이 없는 메소드이다. 어떤 기능 처리를 목적으로 하지 않고 단순히 포인트컷을 식별하는 이름으로만 사용한다.

```java
package com.springbook.biz.common;

import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
public class LogAdvice {
	// @Pointcut 이 붙은 참조 메소드 이름을 이용하여 특정 포인트컷을 지정할 수 있다.
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	
	@Pointcut("execution(* com.springbook.biz..*Impl.get*(..))")
	public void getPointcut() {}
}
```

5.1.3 Advice 설정

Advice 클래스에는 횡단 관심에 해당하는 Advice 메소드가 구현되어 있다. 

이 메소드가 언제 동작할지를 관련 어노테이션을 메소드 위에 설정하면 된다.

이때 반드시 Advice 어노테이션 뒤에 괄호 안에 Pointcut 참조 메소드를 지정하여 Advice 메소드가 결합될 Pointcut 을 참조할 수 있게 해야 한다..

```java
package com.springbook.biz.common;

import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
public class LogAdvice {
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	// allPointcut() 참조 메소드로 지정한 비즈니스 메소드가 호출될 때,
	// 어드바이스 메소드인 printLog() 메소드가 Before 형태로 동작하도록 설정
	@Before("allPointcut")
	public void printLog() {
		System.out.println("[공통 로그] 비즈니스 로직 수행 전 동작");
	}
}
```

5.1.4 Aspect 설정

@Aspect 은 PointCut + Advice 의 결합으로 @Aspect 설정된 Aspect 객체에는 반드시  PointCut 과 Advice 를 결합하는 설정이 있어야 한다.

```java
package com.springbook.biz.common;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
// @Aspect 설정으로 스프링 컨테이너는 LogAdvice 객체를 Aspect 객체로 인식되어
// Pointcut 메소드(allPointcut())와 Advice 메소드(printLog()) 는 
// Weaving 처리 된다.
@Aspect  // Aspect = Pointcut + Advice
public class LogAdvice {

	// 1. allPointcut() 으로 지정한 Pointcut 메소드가 호출될 때,
	// Pointcut
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	
	// 2. printLog() 라는 Advice 메소드가사전 처리 형태로 실행되도록 설정
	// Advice
	@Before("allPointcut()")
	public void printLog() {
		System.out.println("[공통 로그] 비즈니스 로직 수행 전 동작");
	}
}
```

**5.2 Advice 동작 시점**

5.2.1 Before Advice

```java
package com.springbook.biz.common;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
@Aspect  // Aspect = Pointcut + Advice
public class LogAdvice {
	// Pointcut
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	
	// Advice
	@Before("allPointcut()")	
	public void beforeLog(JoinPoint jp) {
		// JoinPoint 객체의 getSignature() 메소드를 이용하여 클라이언트가 호출한 메소드 이름 출력
		String method = jp.getSignature().getName();
		// getArgs() 메소드를 통해 인자 목록을 Object 배열로 얻어낼 수 있어, 메소드 호출에 어떤 값들을 사용했는지 알 수 있다.
		Object[] args = jp.getArgs();
					
		System.out.println("[사전 처리] " + method + "() 메소드 ARGS 정보 : " + args[0].toString());
	}	
}
```

`UserServiceClient` 실행

![Untitled 1](https://user-images.githubusercontent.com/77134124/105853828-781ca180-6029-11eb-8934-9bc4eac2e845.png)

5.2.2 After Returning Advice

```java
package com.springbook.biz.common;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

import com.springbook.biz.user.UserVO;

@Service
@Aspect
public class AfterReturningAdvice {
	@Pointcut("execution(* com.springbook.biz..*Impl.get*(..))")
	public void getPointcut() {}
	
	// afterLog() 는 클라이언트가 호출한 비즈니스 메소드 정보를 알아내기 위해서 
	// JoinPoint 객체를 첫 번째 매개변수로 선언한다.
	// Object 타입의 변수는 '바인드 변수' 로 
	// 바인드 변수란 비즈니스 메소드가 리턴한 결괏값을 바인딩할 목적으로 사용하는데, 
	// 어떤 값이 리턴될지 모르기에 Object 타입으로 선언한다.
	
	// 비즈니스 메소드에서 발생된 예외 객체를 받아낼 바인드 변수를 지정해야 하기 때문에
	// pointcut 속성을 이용하여 포인트 컷을 참조하고 있다.
	@AfterReturning(pointcut="getPointcut()", returning="returnObj")
	public void afterLog(JoinPoint jp, Object returnObj) {
		
		// JoinPoint 객체의 getSignature() 메소드를 이용하여 클라이언트가 호출한 메소드 이름 출력
		String method = jp.getSignature().getName();
		
		if(returnObj instanceof UserVO) {
			UserVO user = (UserVO)returnObj;
			if(user.getRole().equals("Admin")) {
				System.out.println(user.getName() + " 로그인 (Admin)");
			}
		}
		System.out.println("[사후 처리] " + method + "() 메소드 리턴값 : " + returnObj.toString());
	}
}
```

`UserServiceClient` 실행

![Untitled 2](https://user-images.githubusercontent.com/77134124/105853829-78b53800-6029-11eb-8085-88887422893b.png)

5.2.3 After Throwing Advice

```java
package com.springbook.biz.common;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
@Aspect
public class AfterThrowingAdvice {
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	
	// 비즈니스 메소드에서 발생된 예외 객체를 받아낼 바인드 변수를 지정해야 하기 때문에
	// pointcut 속성을 이용하여 포인트 컷을 참조하고 있다.
	@AfterThrowing(pointcut="allPointcut()", throwing="exceptObj")
	public void exceptionLog(JoinPoint jp, Exception exceptObj) {
		
		String method = jp.getSignature().getName();		
		System.out.println(method + "() 메소드 수행 중 예외 발생 ");
		
		if(exceptObj instanceof IllegalArgumentException) {
			System.out.println("부적합한 값이 입력되었습니다.");
		}else if(exceptObj instanceof NumberFormatException) {
			System.out.println("숫자 형식의 값이 아닙니다.");
		}else if(exceptObj instanceof Exception) {
			System.out.println("문제가 발생ㅎㅆ습니다.");
		}
	}
}
```

`BoardServiceClientImpl` 의 insertBoard() 메소드 if 주석 해제 후  `BoardServiceClient` 실행

insertBoard() 메소드가 호출되어 IllegalArgumentException 이 발생할 때 `AfterThrowingAdvice` 가 동작하는 것을 확인할 수 있다.

![Untitled 3](https://user-images.githubusercontent.com/77134124/105853831-78b53800-6029-11eb-89d3-4e23982a6aae.png)

5.2.4 After Advice

```java
package com.springbook.biz.common;

import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
@Aspect
public class AfterAdvice {
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	
	// finallyLog() 메소드가 바인드 변수가 없으므로 포인트컷 메소드만 참조하면 된다.
	@After("allPointcut()")
	public void finallyLog() {
		System.out.println("[사후 처리] 비즈니스 로직 수행 후 무조건 동작");
	}
}
```

`BoardServiceClientImpl` 의 insertBoard() 메소드 if 주석 해제 후  `BoardServiceClient` 실행

![Untitled 4](https://user-images.githubusercontent.com/77134124/105853835-794dce80-6029-11eb-9f7f-aa4247bd1271.png)

5.2.1 Around Advice

사전, 사후 모두 처리

```java
package com.springbook.biz.common;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
@Aspect  // Aspect = Pointcut + Advice
public class LogAdvice {
	// Pointcut
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}
	
	// Advice
	@Before("allPointcut()")	
	public void beforeLog(JoinPoint jp) {
		// JoinPoint 객체의 getSignature() 메소드를 이용하여 클라이언트가 호출한 메소드 이름 출력
		String method = jp.getSignature().getName();
		// getArgs() 메소드를 통해 인자 목록을 Object 배열로 얻어낼 수 있어, 메소드 호출에 어떤 값들을 사용했는지 알 수 있다.
		Object[] args = jp.getArgs();
					
		System.out.println("[사전 처리] " + method + "() 메소드 ARGS 정보 : " + args[0].toString());
	}	
}
```

`BoardServiceClientImpl` 의 insertBoard() 메소드 if 주석 처리 후 

`UserServiceClient` 실행

![Untitled 5](https://user-images.githubusercontent.com/77134124/105853838-79e66500-6029-11eb-824a-be249cbe4500.png)

5.2.1 외부 Pointcut 참조하기

XML 설정으로 포인트컷을 관리했을 때는 스프링 설정 파일에 포인트컷을 여러 개 등록하고 Aspect 설정할 때 pointcut-ref 속성으로 특정 포인트컷을 참조하여 포인트컷을 재사용할 수 있었다.

어노테이션 설정으로 어드바이스 클래스마다 포인트컷 설정이 포함되면서, 비슷하거나 같은 포인트컷이 반복 선언되는 문제가 발생한다. → 외부에 독립된 클래스 따로 설정

```java
package com.springbook.biz.common;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class PrintcutCommon {
	@Pointcut("execution(* com.springbook.biz..*Impl.*(..))")
	public void allPointcut() {}

	@Pointcut("execution(* com.springbook.biz..*Impl.get*(..))")
	public void getPointcut() {}
}
```

정의된 포인트컷을 참조하려면 클래스 이름과 참조 메소드 이름을 조합하여 지정해야 한다.

```java
package com.springbook.biz.common;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

@Service
@Aspect
public class BeforeAdvice {
	// Advice
	@Before("PointcutCommon.allPointcut()")		
	public void beforeLog(JoinPoint jp) {
		// JoinPoint 객체의 getSignature() 메소드를 이용하여 클라이언트가 호출한 메소드 이름 출력
		String method = jp.getSignature().getName();
		// getArgs() 메소드를 통해 인자 목록을 Object 배열로 얻어낼 수 있어, 메소드 호출에 어떤 값들을 사용했는지 알 수 있다.
		Object[] args = jp.getArgs();
						
		System.out.println("[사전 처리] " + method + "() 메소드 ARGS 정보 : " + args[0].toString());
	}	
}
```

![Untitled 6](https://user-images.githubusercontent.com/77134124/105853857-7f43af80-6029-11eb-8db1-4031fb2e68e5.png)

```java
package com.springbook.biz.common;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

import com.springbook.biz.user.UserVO;

@Service
@Aspect
public class AfterReturningAdvice {
	// afterLog() 는 클라이언트가 호출한 비즈니스 메소드 정보를 알아내기 위해서 
	// JoinPoint 객체를 첫 번째 매개변수로 선언한다.
	// Object 타입의 변수는 '바인드 변수' 로 
	// 바인드 변수란 비즈니스 메소드가 리턴한 결괏값을 바인딩할 목적으로 사용하는데, 
	// 어떤 값이 리턴될지 모르기에 Object 타입으로 선언한다.
	
	// @AfterReturning 은 pointcut 속성을 이용하여 포인트컷을 차모하고 있다
	// 이는 비즈니스 메소드 수행 결과를 받아내기 위해 바인드 변수를 지정해야 하기 때문이다.
	@AfterReturning(pointcut="PointcutCommon.getPointcut()", returning="returnObj")
	public void afterLog(JoinPoint jp, Object returnObj) {
		
		// JoinPoint 객체의 getSignature() 메소드를 이용하여 클라이언트가 호출한 메소드 이름 출력
		String method = jp.getSignature().getName();
		
		if(returnObj instanceof UserVO) {
			UserVO user = (UserVO)returnObj;
			if(user.getRole().equals("Admin")) {
				System.out.println(user.getName() + " 로그인 (Admin)");
			}
		}
		System.out.println("[사후 처리] " + method + "() 메소드 리턴값 : " + returnObj.toString());
	}
}
```
# Class 06 스프링 JDBC

**6.1 스프링 JDBC 개념**

JDBC 는 가장오랫동안 자바 개발자들이 사용한 DB 연동 기술이다.

JDBC 를 이용하여 DB 연동 프로그램을 개발하면 데이터베이스에 비종속적인 DB 연동 로직을 구현할 수 있다. 그런데 작성해야 할 코드가 너무 많다는 단점이 있다.

```java
package com.springbook.biz.user.impl;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import org.springframework.stereotype.Repository;

import com.springbook.biz.common.JDBCUtil;
import com.springbook.biz.user.UserVO;

// DAO(Data Access Object
@Repository("userDAO")
public class UserDAO {
	
	// JDBC 관련 변수
	private Connection conn;
	private PreparedStatement pstmt;
	private ResultSet rs;
	
	// SQL 명령어들
	private final String USER_GET = "select * from users where id=?";
	
	// CRUD 기능을 메소드 구현
	// 회원 조회
	public UserVO getUser(UserVO vo) {
		System.out.println("===> JDBC로 getUser() 기능 처리");
		UserVO user = null;
		
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			String url = "jdbc:oracle:thin:@localhost:1521:xe";
			
			conn = DriverManager.getConnection(url, "hr", "hr");
			pstmt = conn.prepareStatement(USER_GET);
			
			pstmt.setString(1, vo.getId());
			
			rs = pstmt.executeQuery();
			
			if (rs.next()) {
				user = new UserVO();
				user.setId(rs.getString("ID"));
				user.setPassword(rs.getString("PASSWORD"));
				user.setName(rs.getString("NAME"));
				user.setRole(rs.getString("ROLE"));
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			try {
				if (rs != null) rs.close();
			}catch (Exception e) {
				e.printStackTrace();
			}finally {
				rs = null;
			}
			try {
				if (pstmt != null) pstmt.close();
			}catch(Exception e) {
				e.printStackTrace();
			}finally {
				pstmt =null;
			}
			try {
				if (conn != null) conn.close();
			}catch(Exception e){e.printStackTrace();
				e.printStackTrace();
			}finally {
				conn = null;
			}
		}		
		return user;
		
	}
}
```

JDBCUtil 클래스를 이용하여 커넥션 연결과 해제 로직을 대체할 수도 있으니 이 역시 많은 양의 코드가 필요하다. 

아래 JDBCUtil 클래스를 사용하여 구현한 BoardDAO 클래스의 insertBoard() 와 updateBoard() 메소드의 실행되는 SQL 구문의 "? "에 설정하는 값만 다를 뿐, JDBC 에 해당하는 자바 코드는 거의 같다.

```java
package com.springbook.biz.board.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Repository;

import com.springbook.biz.board.BoardVO;
import com.springbook.biz.common.JDBCUtil;

// DAO(Data Access Object)
// DB 연동을 처리 & 연동 과정에서 발생하는 예외를 변환
@Repository("boardDAO")
public class BoardDAO {
	// JDBC 관련 변수
	private Connection conn = null;
	private PreparedStatement pstmt = null;
	private ResultSet rs = null;
	
	// SQL 명령어들_상수 처리
	private final String BOARD_INSERT = "insert into board(SEQ, TITLE, WRITER, CONTENT) "
																	  + "values((select nvl(max(seq), 0)+1 from board),?,?,?)";
	
	private final String BOARD_UPDATE = "update board set title=?, content=? where seq=?";
	
	private final String BOARD_DELETE = "delete board where seq=?";
	private final String BOARD_GET 	  = "select * from board where seq=?";
	private final String BOARD_LIST   = "select * from board order by seq desc";
	
	// CRUD 기능의 메소드 구현
	// 글 등록
	public void insertBoard(BoardVO vo) {
		System.out.println("===> JDBC로 insertBoard() 기능 처리");
		
		try {
			conn = JDBCUtil.getConnection();
			pstmt = conn.prepareStatement(BOARD_INSERT);
			
			pstmt.setString(1, vo.getTitle());
			pstmt.setString(2, vo.getWriter());
			pstmt.setString(3, vo.getContent());
			
			pstmt.executeUpdate();
			
		} catch(Exception e) {
			e.printStackTrace();
		} finally {
			JDBCUtil.close(pstmt, conn);
		}
	}
	
	// 글 수정
	public void updateBoard(BoardVO vo) {
		System.out.println("===> JDBC로 updateBoard() 기능 처리");
		
		try {
			conn = JDBCUtil.getConnection();
			pstmt = conn.prepareStatement(BOARD_UPDATE);
			
			pstmt.setString(1, vo.getTitle());
			pstmt.setString(2, vo.getContent());
			pstmt.setInt(3, vo.getSeq());
			
			pstmt.executeUpdate();
			
		} catch(Exception e) {
			e.printStackTrace();
		} finally {
			JDBCUtil.close(pstmt, conn);
		}
	}
	
	// 글 삭제
	public void deleteBoard(BoardVO vo) {
		System.out.println("===> JDBC로 deleteBoard() 기능 처리");
		
		try {
			conn = JDBCUtil.getConnection();
			pstmt = conn.prepareStatement(BOARD_DELETE);
			
			pstmt.setInt(1,vo.getSeq());
			
			pstmt.executeUpdate();
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			JDBCUtil.close(pstmt, conn);
		}
	}
	
	// 글 상세 조회
	public BoardVO getBoard(BoardVO vo) {
		System.out.println("===> JDBC로 getBoard() 기능 처리");
		BoardVO board = null;
		
		try {
			conn = JDBCUtil.getConnection();
			pstmt = conn.prepareStatement(BOARD_GET);
			
			pstmt.setInt(1,vo.getSeq());
			rs = pstmt.executeQuery();
			
			if (rs.next()) {
			
				board = new BoardVO();
				board.setSeq(rs.getInt("SEQ"));
				board.setTitle(rs.getString("TITLE"));
				board.setWriter(rs.getString("WRITER"));
				board.setContent(rs.getString("CONTENT"));
				board.setRegDate(rs.getDate("REGDATE"));
				board.setCnt(rs.getInt("CNT"));
			}	
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			JDBCUtil.close(rs, pstmt, conn);
		}
		return board;
	}
	
	// 글 목록 조회
	public List<BoardVO> getBoardList(BoardVO vo) {
		System.out.println("===> JDBC로 getBoardList() 기능 처리");
		List<BoardVO> boardList = new ArrayList<BoardVO>();
		
		try {
			conn = JDBCUtil.getConnection();
			pstmt = conn.prepareStatement(BOARD_LIST);
			rs = pstmt.executeQuery();
			
			while (rs.next()) {
			
				BoardVO board = new BoardVO();
				board.setSeq(rs.getInt("SEQ"));
				board.setTitle(rs.getString("TITLE"));
				board.setWriter(rs.getString("WRITER"));
				board.setContent(rs.getString("CONTENT"));
				board.setRegDate(rs.getDate("REGDATE"));
				board.setCnt(rs.getInt("CNT"));
				
				boardList.add(board);
				
			}	
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			JDBCUtil.close(rs, pstmt, conn);
		}
		return boardList;
	}
}
```

이런 환경에서 새로운 기능의 메소드를 개발하려면, 기존 메소드를 복사하여 SQL 만 수정하는 방법뿐이다. 스프링은 JDBC 기반의 DB 연동 프로그램을 쉽게 개발할 수 있도록 JdbcTemplate 클래스를 지원한다.

![Untitled](https://user-images.githubusercontent.com/77134124/105853883-85d22700-6029-11eb-81f9-e5ba3de17c8d.png)

JdbcTemplate 은 JDBC 의 반복적인 코드를 제거하기 위해 제공하는 클래스다.

DAO 클래스에서는 JdbcTemplate 클래스가 제공하는 템플릿 메소드를 호출하여 DB 연동을 간단하게 처리할 수 있다. 이때 JdbcTemplate 클래스는 내부적으로 JDBC API 를 이용하여 실제 DB 연동 작업을 처리한다.

**6.2 JbdcTemplate 클래스**

JbdcTemplate 은 템블릿 메소드 패턴이 적용된 클래스로, 템플릿 메소드는 패턴은 복잡하고 반복되는 알고리즘을 캡슐화해서 재사용할 수 있어 JDBC 처럼 코딩 순서가 정형화된 기술에서 유용하게 사용할 수 있다.

따라서 반복되는 DB 연동 로직은 JdbcTemplate 클래스의 템플릿 메소드가 제공하고 개발자는 달라지는 SQL 구문과 같은 설정값만 신경 쓰면 된다.

**6.3 스프링 JDBC 설정**

6.3.1 라이브러리 추가

스프링 JDBC 를 이용하려면 `pom.xml` 파일에 DBCP 관련 <depencency> 설정을 추가해야 한다.

에러 발생하니 주의

```xml
<!-- Spring -->
		<!-- 생략 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		
		<!-- DBCP -->
		<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
				
		<!-- AspectJ -->
```

![Untitled 1](https://user-images.githubusercontent.com/77134124/105853893-8965ae00-6029-11eb-82db-78aaa08e7de1.png)

6.3.2 <bean> 등록하여 **DataSource 설정**

JdbcTemplate 클래스가 JDBC API 를 이용하여 DB 연동을 처리하려면 반드시 DB 로부터 커넥션을 얻어야 한다. 따라서 JdbcTemplate 객체가 사용할 DataSource 를 <bean> 등록하여 스프링 컨테이너가 생성하도록 해야 한다.

DataSource 설정은 스프링 JDBC 뿐만 아니라 트랜잭션 처리, Mybatis 연동, JPA 연동에서도 사용되므로 중요한 설정이다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:p="http://www.springframework.org/schema/p"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="http://www.springframework.org/schema/beans 
                      http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context 
                      http://www.springframework.org/schema/context/spring-context-4.2.xsd
                      http://www.springframework.org/schema/aop
                      http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
				   
	<!-- base-package="com.springbook.biz" 로 지정하면 
			 com.springbook.biz 패키지로 시작하는 모듵 패키지를 스캔 대상에 포함 & 객체 생성한다  -->
	<context:component-scan base-package="com.springbook.biz"></context:component-scan>
	
	<!-- DataSource 설정 -->
	<!-- 일반적으로 가장 많이 사용하는 Apache 의 BasicDataSource 등록
			 BasicDataSource 객체는 연결에 필요한 property 들을 Setter 인젝션으로 설정해주면 되고
			 BasicDataSource 객체가 삭제되기 전에 연결을 해제하고자 close() 메소드를 destroy-method 속성으로 지정 -->
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver" />
		<property name="url" value="jdbc:h2:tcp://localhost/~/test" />
		<property name="username" value="sa" />
		<property name="password" value="" />
	</bean>
	
	<!-- 스프링 컨테이너가 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다. -->
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
</beans>
```

6.3.3 프로퍼티 파일을 활용한 **DataSource 설정**

PropertyPlaceholderConfigurer 를 이용하여 외부의 Property 파일을 참조하여 DataSource 를 설정할 수 있다.

이클립스 내 **properties 파일** 생성
`Ctrl + N` or 패키지를 `마.오` 클릭 -> `New` - `Other` → `General` - `Untitled Text File` 선택
Untitled 1 창이 나오면 여기에 [db.properties](http://db.properties)의 내용을 적은 후
`Save As` - `파일 경로 선택 및 File Name` 에 **db.properties** 기입하면 **db.properties 파일 생성**

```
jdbc.driver=org.h2.Driver
jdbc.url=jdbc:h2:tcp://localhost/~/test
jdbc.username=sa
jdbc.password=
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:p="http://www.springframework.org/schema/p"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="http://www.springframework.org/schema/beans 
                      http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context 
                      http://www.springframework.org/schema/context/spring-context-4.2.xsd
	                    http://www.springframework.org/schema/aop
                      http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
						   
	<!-- base-package="com.springbook.biz" 로 지정하면 
			 com.springbook.biz 패키지로 시작하는 모듵 패키지를 스캔 대상에 포함 & 객체 생성한다  -->
	<context:component-scan base-package="com.springbook.biz"></context:component-scan>
	
	<!-- 스프링 컨테이너가 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다. -->
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

	<!-- DataSource 설정 -->
	<!-- property 파일에 설정된 properties 를 이용하여 DataSource 를 설정하려면
			 context:property-placeholder> 엘리먼트를 사용한다-->
	<context:property-placeholder location="classpath:config/database.properties" />
	
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- ${} 구문을 이용하여 property 이름을 지정하면 프로퍼티 값으로 치환되어 실행된다.  -->
		<property name="driverClassName" value="${jdbc.driver}" />
		<property name="url" value="${jdbc.url}" />		
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>
		
</beans>
```

**6.4 JdbcTempate 메소드**

스프링 JDBC 를 위한 기본 설정이 마무리됐으면 JdbcTemplate 객체를 이용하여 DB 연동을 간단하게 처리할 수 있다.

6.4.1 update() 메소드

```java
public void updateBoard(BoardVO vo) {
	String BOARD_UPDATE = "update board set title=?, content=? where seq=?";
	// 1. SQL 구문에 설정된 "?" 수 만큼 값들을 차례대로 나열
	int cnt = jdbcTemplate.update(BOARD_UPDATE, vo.getTitle(), vo.getContent(), vo.getSeq());
	
	System.out.println(cnt + "건 데이터 수정");
}
```

```java
public void updateBoard(BoardVO vo) {
	String BOARD_UPDATE = "update board set title=?, content=? where seq=?";
	// 2. Object 배열 객체에 SQL 구문에 설정된 "?" 수 만큼 값들을 세팅하여 
	//    배열 객체를 두 번째 인자로 전달하는 방식이다.
	Object[] args = {vo.getTitle(), vo.getContent(), vo.getSeq()};
	int cnt = jdbcTemplate.update(BOARD_UPDATE, args);
	
	System.out.println(cnt + "건 데이터 수정");
}
```

6.4.2 queryForInt() 메소드

```java
public int getBoardTotalCount(BoardVO vo) {
	String BOARD_TOT_COUNT = "select count(*) from board";
	// SELECT 구문으로 검색된 정숫값을 리턴받으려면 
	// queryForInt() 메소드를 사용한다.	
	int count = jdbcTemplate.queryForInt(BOARD_TOT_COUNT);
	System.out.println("전체 게시글 수 : " + cnt + "건");
}
```

6.4.3 queryForObject() 메소드

SELECT 문으로 객체 하나를 검색할 때 사용하는 메소드

```java
public BoardVO getBoard(BoardVO vo) {
	String BOARD_GET = "select count(*) from board where seq=?";
	// SELECT 구문으로 검색된 결과를 특정 자바 객체로 매핑하여 리턴을 받는다
	// queryForObject() 메소드는 검색 결과가 없거나 검색 결과가 두 개 이상이면 
	// 예외(IncorrectResultSizeDataAccessException) 을 발생시킨다.	
	Object[] args = {vo.getSeq()};
	
	// RowMapper 객체를 queryForObject() 메소드의 매개변수로 넘겨주면,
	// 스프링 컨테이너는 SQL 구문을 수행한 후 
	// 자동으로 RowMapper 객체의 mapRow() 메소드를 호출한다.
	return jdbcTemplate.queryForObject(BOARD_GET, args, new BoardRowMapper());
}
```

특정 VO 객체에 매핑하여 리턴하려면 RowMapper 인터페이스를 구현한 RowMapper 클래스가 필요하다. 테이블당 하나씩은 필요하다.

**RowMapper 인터페이스**에는 mapRow() 메소드가 있어서 검색 결과로 얻어낸 Row 정보를 어떤 VO에 어떻게 매핑할 것인지를 구현해주면 된다.

```java
package com.springbook.biz.board.impl;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.jdbc.core.RowMapper;

import com.springbook.biz.board.BoardVO;

public class BoardRowMapper implements RowMapper<BoardVO>{

	public BoardVO mapRow(ResultSet rs, int rowNum) throws SQLException {
	
		BoardVO board = new BoardVO();

		board.setSeq(rs.getInt("SEQ"));
		board.setTitle(rs.getString("TITLE"));
		board.setWriter(rs.getString("WRITER"));
		board.setRegDate(rs.getDate("REGDATE"));
		board.setCnt(rs.getInt("CNT"));
		
		return board;
	}
}
```

6.4.4 query() 메소드

SELECT 문의 실행 결과가 목록일 때 사용하는 메소드로 기본 사용법은 queryForObject() 메소드와 같다. (RowMapper 객체 사용)

```java
public List<BoardVO> getBoardList(BoardVO vo) {
	String BOARD_LIST = "select * from board order by seq desc";
	return jdbcTemplate.query(BOARD_LIST, new BoardRowMapper());
```

query() 메소드가 실행되면 여러 건의 ROW 정보가 검색되며, 검색된 데이터 ROW 수만큼 RowMapper 객체의 mapRow() 메소드가 실행되고 ROW 정보가 매핑된 VO 객체 여러 개가 List 컬렉션에 저장되어 리턴된다.

**6.5 DAO 클래스 구현**

DAO 클래스에서 JdbcTemplate 객체를 얻는 방법은 두 가지 이다.

6.5.1 첫 번째 방법 : JdbcDaoSupport 클래스 상속

```java
package com.springbook.biz.board.impl;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
import org.springframework.stereotype.Repository;

import com.springbook.biz.board.BoardVO;

// DAO(Data Access Object)
// JdbcDaoSupport 클래스를 부모 클래스로 지정하면
// getJdbcTemplate() 메소드를 상속 받을 수 있다.
// getJdbcTemplate() 메소드를 호출하면 JdbcTemplate 객체가 리턴되어
// 모든 메소드를 JdbcTemplate 객체로 구현할 수 있다.
@Repository           
public class BoardDAOSpring extends JdbcDaoSupport{
	// SQL 명령어들
	private final String BOARD_INSERT = "insert into board(seq, title, writer, content) values((select nvl(max(seq), 0)+1 from board), ?, ?, ?)";
	private final String BOARD_UPDATE = "update board set title=?, content=? where seq=?";
	private final String BOARD_DELETE = "delete board where seq=?";
	private final String BOARD_GET = "select * from board where seq=?";
	private final String BOARD_LIST = "select * from board order by seq desc";
	
	// 해당 메소드를 스프링 컨테이너가 자동으로 호출하여, 
  // 메소드 매개변수 타입을 확인하고 해당 타입의 객체가 메모리에 존재하면 
	// 그 객체를 인자로 넘겨준다.
	@Autowired 	
	// getJdbcTemplate() 메소드가 JdbcTemplate 객체를 리턴하려면
	// DataSource 객체를 가지고 있어야 한다.
	// 따라서 반드시 부모 클래스 JdbcDaoSupport 클래스의 setDataSource() 메소드를 호출하여
	// 데이터소스 객체를 의존성 주입해야 한다.	
	public void setSuperDataSource(DataSource dataSource) {
		super.setDataSource(dataSource);
	}
	
	// CRUD 기능의 메소드 구현
	// 글 등록
	public void insertBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC insertBoard() 기능 처리");
		getJdbcTemplate().update(BOARD_INSERT, vo.getTitle(), vo.getWriter(), vo.getContent());
	}
		
	// 글 수정
	public void updateBorad(BoardVO vo) {
		System.out.println("===> Spring JDBC updateBorad() 기능 처리");
		getJdbcTemplate().update(BOARD_UPDATE, vo.getTitle(), vo.getContent(), vo.getSeq());
	}
	
	// 글 삭제
	public void deleteBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC deleteBoard() 기능 처리");
		getJdbcTemplate().update(BOARD_DELETE,vo.getSeq());
	}
		
	// 글 상세 조회
	public BoardVO getBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC getBoard() 기능 처리");
		Object[] args = {vo.getSeq()};
			
		return getJdbcTemplate().queryForObject(BOARD_GET, args, new BoardRowMapper());			
	}
		
	// 글 목록 조회
	public List<BoardVO> getBoardList(BoardVO vo) {
		System.out.println("===> Spring JDBC getBoardList() 기능 처리");
			
		return getJdbcTemplate().query(BOARD_LIST, new BoardRowMapper());			
	}
}
```

`BoardServiceImpl` 클래스가 **BoardDAOSpring** 객체를 이용하여 DB 연동을 처리하도록 수정 

```java
@Service("boardService")
public class BoardServiceImpl implements BoardService {
 
    @Autowired
    private BoardDAOSpring boardDAO; // 변경해줄 것
 
}
```

![Untitled 2](https://user-images.githubusercontent.com/77134124/105853897-89fe4480-6029-11eb-9083-9c005e270208.png)

6.5.2 두 번째 방법 : JdbcTemplate 클래스 <bean> 등록, 의존성 주입

스프링 설정 파일에 JdbcTemplate 클래스를 <bean> 등록한다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:p="http://www.springframework.org/schema/p"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="http://www.springframework.org/schema/beans 
                      http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context 
                      http://www.springframework.org/schema/context/spring-context-4.2.xsd
                      http://www.springframework.org/schema/aop
                      http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
						   
	<!-- base-package="com.springbook.biz" 로 지정하면 
			 com.springbook.biz 패키지로 시작하는 모듵 패키지를 스캔 대상에 포함 & 객체 생성한다  -->
	<context:component-scan base-package="com.springbook.biz"></context:component-scan>
	
	<!-- 스프링 컨테이너가 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다. -->
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

	<!-- DataSource 설정 -->
	<!-- property 파일에 설정된 properties 를 이용하여 DataSource 를 설정하려면
			 context:property-placeholder> 엘리먼트를 사용한다-->
	<context:property-placeholder location="classpath:config/database.properties" />
	
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- ${} 구문을 이용하여 property 이름을 지정하면 프로퍼티 값으로 치환되어 실행된다.  -->
		<property name="driverClassName" value="${jdbc.driver}" />
		<property name="url" value="${jdbc.url}" />		
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>

	<!-- Spring JDBC 설정 : 1. JdbcTemplate 객체에 의존성 주입-->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>	
</beans>
```

```java
package com.springbook.biz.board.impl;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
import org.springframework.stereotype.Repository;

import com.springbook.biz.board.BoardVO;

// DAO(Data Access Object)
@Repository
public class BoardDAOSpring{

	// 해당 메소드를 스프링 컨테이너가 자동으로 호출하여, 
  // 메소드 매개변수 타입을 확인하고 해당 타입의 객체가 메모리에 존재하면 
	// 그 객체를 인자로 넘겨준다.

  // 2.JdbcTemplate 타입의 객체를 의존성 주입 처리
	@Autowired
	private JdbcTemplate jdbcTemplate;
 
	// SQL 명령어들
	private final String BOARD_INSERT = "insert into board(seq, title, writer, content) values((select nvl(max(seq), 0)+1 from board), ?, ?, ?)";
	private final String BOARD_UPDATE = "update board set title=?, content=? where seq=?";
	private final String BOARD_DELETE = "delete board where seq=?";
	private final String BOARD_GET = "select * from board where seq=?";
	private final String BOARD_LIST = "select * from board order by seq desc";
	

	@Autowired 	
	// getJdbcTemplate() 메소드가 JdbcTemplate 객체를 리턴하려면
	// DataSource 객체를 가지고 있어야 한다.
	// 따라서 반드시 부모 클래스 JdbcDaoSupport 클래스의 setDataSource() 메소드를 호출하여
	// 데이터소스 객체를 의존성 주입해야 한다.	
	public void setSuperDataSource(DataSource dataSource) {
		super.setDataSource(dataSource);
	}
	
	// CRUD 기능의 메소드 구현
	// 글 등록
	public void insertBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC insertBoard() 기능 처리");
		jdbcTemplate.update(BOARD_INSERT, vo.getTitle(), vo.getWriter(), vo.getContent());
	}
		
	// 글 수정
	public void updateBorad(BoardVO vo) {
		System.out.println("===> Spring JDBC updateBorad() 기능 처리");
		jdbcTemplate.update(BOARD_UPDATE, vo.getTitle(), vo.getContent(), vo.getSeq());
	}
	
	// 글 삭제
	public void deleteBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC deleteBoard() 기능 처리");
		jdbcTemplate.update(BOARD_DELETE,vo.getSeq());
	}
		
	// 글 상세 조회
	public BoardVO getBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC getBoard() 기능 처리");
		Object[] args = {vo.getSeq()};
			
		return jdbcTemplate.queryForObject(BOARD_GET, args, new BoardRowMapper());			
	}
		
	// 글 목록 조회
	public List<BoardVO> getBoardList(BoardVO vo) {
		System.out.println("===> Spring JDBC getBoardList() 기능 처리");
			
		return jdbcTemplate.query(BOARD_LIST, new BoardRowMapper());			
	}
}
```

```java
@Service("boardService")
public class BoardServiceImpl implements BoardService {
 
    @Autowired
    private BoardDAOSpring boardDAO; // 변경해줄 것
 
}
```

![Untitled 3](https://user-images.githubusercontent.com/77134124/105853898-8a96db00-6029-11eb-9ebc-b45e4fbf6ef9.png)


# Class 07 트랜젝션 처리

EJB 는 모든 비즈니스 메소드에 대한 트랜잭션 관리를 EJB 컨테이너가 자동으로 처리해준다. 스프링에서도 '선언적 트랜잭션' 처리를 통해 EJB와 마찬가지로 트랜잭션 처리를 컨테이너가 자동으로 처리하게 설정할 수 있다.

스프링 트랜잭션 설정할 때는 XML 기반의 AOP 설정만 사용할 수 있고, 어노테이션은 사용할 수 없다. <aop:advisor> 엘리먼트만 사용할 수 있고 <aop:aspect> 엘리먼트는 사용하지 못한다.

**7.1 트랜잭션 네임스페이스 등록**

`applicationContext.xml` [Namespaces] 탭을 선택하고 tx 네임스페이스 추가

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans 
                      http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context 
                      http://www.springframework.org/schema/context/spring-context-4.2.xsd
                      http://www.springframework.org/schema/aop
                      http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
                      http://www.springframework.org/schema/tx
                      http://www.springframework.org/schema/tx/spring-tx-4.2.xsd">
						   
</beans>
```

**7.2 트랜젝션 관리자 등록**

트랜젝션 관련 설정에서 가장 먼저 등록하는 것은 트랜잭션 관리자 클래스다.

어떤 기술을 이용하여 데이터베이스 연동을 처리했느냐에 따라 트랜잭션 관리자가 달라지며, 모든 트랜잭션 관리자는 `PlatformTransactionManager` **인터페이스**를 구현한 클래스들이다.

```java
public interface PlatformTransactionManager {
	TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
void commit(TransactionStatus status) throws TransactionException;
void rollback(TransactionStatus status) throws TransactionException;
}
```

따라서 스프링이 제공하는 모든  트랜잭션 관리자는 트랜잭션 관리에 필요한 commit(), rollback() 메소드를 가지고 있다.

현재 가지고 있는 두 개의 DAO 클래스는 모두 JDBC 를 기반으로 동작하기에 DataSourceTransactionManager 클래스를 이용하여 트랜잭션을 처리할 것이다. 이후에 Mybatis 와 JPA 를 이용하여 DAO 클래스를 추가로 구현할 때 트랜잭션 관리자를 변경해주면 된다. (JPA → JPATransactionManager 등록)

스프링 설정 파일에 DataSourceTransactionManager 클래스를 <bean> 에 등록

하지만, DataSourceTransactionManager 를 <bean> 등록했다고 해서 자동으로 트랜잭션 관리가 되는 것이 아니다. 

다른 트랜잭션 관리자와 마찬가지로 PlatformTransactionManager 의 commit(), rollback() 메소드를 재정의(Overriding) 하여 구현하고 있을 뿐이다. PlatformTransactionManager 객체 스스로 자신이 가진 메소드를 실행할 수는 없다.

![Untitled](https://user-images.githubusercontent.com/77134124/105853920-92ef1600-6029-11eb-9e39-cb8e4de3cfac.png)

어드바이스는 비즈니스 메소드 실행 전이나 후에 동작하여 비즈니스 메소드와 무관하게 공통 기능을 제공하는데 그중 가장 대표적인 것이 예외 처리와 트랜잭션 처리이다.

비즈니스 메소드가 실행되다 예외가 발생하면 해당 메소드에 대한 **트랜잭션을 롤백하고**, 문제없이 정상으로 수행 종료되면 트랜잭션을 **커밋**하면 된다. 이러한 동작을 위한 객체는 DataSourceTransactionManager 로 등록했다. 이제 트랜잭션 관리자를 이용하여 트랜잭션을 제어하는 어드바이스만 등록하면 된다.

**7.3 트랜잭션 관리 어드바이스 설정**

트랜잭션 관리 기능의 어드바이스는 <tx:advice> 엘리먼트를 사용하여 설정한다.

앞서 트랜잭션 설정을 위한 tx 네임스페이스를 추가했으므로 스프링 설정 파일에 <tx:advice> 엘리먼트를 이용하여 트랜잭션 관리 어드바이스를 설정한다.

지금까지 AOP 관련 설정에 사용한 모든 어드바이스 클래스를 우리가 직접 구현했던 것과 달리, 트랜잭션 관리 어드바이스는 스프링 컨테이너가 <tx:advice> 설정을 참조하여 자동으로 생성한다.

이는 트랜잭션 관리 어드바이스 객체에 클래스 이름이나 메소드를 확인할 수 없다는 의미로, 우리는 단지 생성되는 어드바이스의 아이디를 id 속성으로, 어드바이스 객체가 사용할 트랜잭션 관리자를 transaction-manager 속성으로 지정할 뿐이다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans 
                      http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context 
                      http://www.springframework.org/schema/context/spring-context-4.2.xsd
                      http://www.springframework.org/schema/aop
                      http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
                      http://www.springframework.org/schema/tx
                      http://www.springframework.org/schema/tx/spring-tx-4.2.xsd">
						   
	<context:component-scan base-package="com.springbook.biz" />

	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

	<!-- DataSource 설정 -->
	<context:property-placeholder location="classpath:config/database.properties" />
	
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
		destroy-method="close">
		<property name="driverClassName" value="${jdbc.driver}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>	
<!-- 	
	Spring JDBC 설정
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>
 -->	
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<!-- 트랜잭션 관리 기능의 어드바이스 설정 -->
	<!-- txAdvice 라는 어드바이스가 앞에 설정한 txManager 를 이용하여 트랜잭션을 관리한다는 설정-->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
		<!-- get으로 시작하는 모든 메소드는 읽기 전용으로 처리되어
				 트랜잭션 관리 대상에서 제외하고 나머지 메소드들은 트랜잭션 관리에 포함한 것이다 -->
			<tx:method name="get*" read-only="true"/> 
			<tx:method name=""/>
		</tx:attributes>
	</tx:advice>
</beans>
```

<tx:method> 엘리먼트가 가지고 있는 속성

**name** : 트랜잭션이 적용될 메소드 이름 지정

**read-only** : 읽기 전용 지정((default : "false")

**no-rollback-for** : 트랜잭션을 롤백하지 않을 예외 지정

**rollback-for** : 트랜잭션을 **롤백할** 예외 지정

**7.4 AOP 설정을 통한 트랜잭션 적용**

비즈니스 메소드 실행 후 트랜잭션 관리 어드바이스가 동작하도록 AOP 설정을 추가해야 한다. 이때 <aop:aspect>가 아닌 <aop:advisor> 엘리먼트를 사용한다.

<aop:advice> 와 <aop:aspect> 는 포인트컷과 어드바이스의 결합이라는 측면에서 같으나, <aop:aspect> 엘리먼트를 사용하려면 다음과 같이 포인트컷과 결합할 어드바이스 객체의 아이디와 어드바이스 메소드 이름을 알아야 한다.

```java
public class LogAdvice {

	public void printLog() {
		System.out.println("[공통 로그] 비즈니스 로직 수행 전 동작");
	}	
}
```

```xml
<bean id="log" class="com.springbook.biz.common.LogAdvice"></bean>
	<aop:config>
		<!-- id 는 포인트컷을 식별하기 위한 유일한 문자열 execution 은 갑슬 어떻게 설정하느냐에 따라 필터링되는 메소드가 달라진다.  -->
		<!-- allPointcut 은 com.springbook.biz 패키지로 시작하는 클래스 중에서 
				 이름이 Impl 로 끝나는 클래스의 모든 메소드를 포인트컷으로 설정했다 -->
		<aop:pointcut id="allPointcut" expression="execution(* com.springbook.biz..*Impl.*(..))"/>

		<!-- aspect 설정에서 <aop:before> 엘리먼트의 pointcut-ref 속성으로 포인트컷을 참조-->		
		<aop:aspect ref="log">
					<aop:before pointcut-ref="allPointcut" method="printLog"/>
		</aop:aspect>
	</aop:config>
```

그러나 트랜잭션 관리 어드바이스는 <tx:advice> 설정으로 스프링 컨테이너가 자동으로 생성하므로 어드바이스 메소드 이름을 알 수 없기에 <aop:aspect> 엘리먼트를 사용할 수 없는 것이다. 

txPointcut 으로 지정한 메소드가 호출될 때, txAdvice 로 등록한 어드바이스가 동작하여 트랜잭션을 관리하도록 설정한다.

![Untitled 1](https://user-images.githubusercontent.com/77134124/105853950-9aaeba80-6029-11eb-9819-3d70d4976eb5.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                      http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context 
                      http://www.springframework.org/schema/context/spring-context-4.2.xsd
                      http://www.springframework.org/schema/aop
                      http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
                      http://www.springframework.org/schema/tx
                      http://www.springframework.org/schema/tx/spring-tx-4.2.xsd">
						   
	<context:component-scan base-package="com.springbook.biz" />

	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

	<!-- DataSource 설정 -->
	<context:property-placeholder location="classpath:config/database.properties" />
	
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driver}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
<!-- 		
		<property name="driverClassName" value="org.h2.Driver" />
		<property name="url" value="jdbc:h2:tcp://localhost/~/test" />
		<property name="username" value="sa" />
		<property name="password" value="" />		
 -->	
 </bean>	
 	
	<!-- Spring JDBC 설정  -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>
	
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<!-- 트랜잭션 관리 기능의 어드바이스 설정 -->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true"/>
			<tx:method name=""/>
		</tx:attributes>
	</tx:advice>
	<!-- 트랜잭션 관리 어드바이스가 동작하도록 AOP 설정을 추가 -->
	<aop:config>
		<aop:pointcut id="txPointcut" expression="execution(* com.springbook.biz..*(..))" />
		<aop:advisor pointcut-ref="txPointcut" advice-ref="txAdvice"/>
	</aop:config>
</beans>
```

![Untitled 2](https://user-images.githubusercontent.com/77134124/105853963-9bdfe780-6029-11eb-8945-27a0f43cb2f6.png)

1. 클라이언트가 BoardServiceImpl 객체의 insertBoard() 메소드를 호출하면

2. insertBoard() 메소드의 비즈니스 로직이 수행된다. 만약 insertBoard() 메소드 수행 중에 문제가 발생하면

3. txAdvice 로 등록한 어드바이스가 동작하여, 

4. 참조하는 txManager 의 rollback() 메소드를 호출한다. 만약 문제없이 정상으로 수행되었다면 commit() 메소드를 호출한다.

**7.5 트랜잭션 설정 테스트**

우선 BoardServiceClient 에서 명시적으로 100번 글을 등록하도록 한다.

```java
package com.springbook.biz.board.impl;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.springbook.biz.board.BoardService;
import com.springbook.biz.board.BoardVO;
import com.springbook.biz.common.Log4jAdvice;
import com.springbook.biz.common.LogAdvice;

// 비즈니스로직 처리를 위한 객체 생성
// 클라이언트 프로그램에서 boardService 라는 이름으로 객체를 요청할 수 있도록 id 설정
@Service("boardService")
public class BoardServiceImpl implements BoardService {
	
	// DB 연동이 포함된 비즈니스 로직 처리를 위하여 BoardDAO 타입의 객체를 멤버 변수로 가지고 있다.
	// 이 변수에 BoardDAO 타입의 객체를 의존성 주입하기 위해서 변수 위에 @Autowired
	@Autowired
	private BoardDAOSpring boardDAO;
//	private LogAdvice log;
//	private Log4jAdvice log;
	
//	public BoardServiceImpl() {
//		log = new Log4jAdvice();
//	}

	@Override
	public void insertBoard(BoardVO vo) {
//		log.printLogging();
		// After Throwing Advice 확인을 위한 추가
//		if(vo.getSeq() == 0) {
//			throw new IllegalArgumentException("0번 글은 등록할 수 없습니다.");
//		}
		if (vo.getSeq() == 0) {
			throw new IllegalArgumentException("0번 글은 등록할 수 없습니다.");
		}
		// BoardServiceImpl 클래스의 insertBoard() 메소드에서 
		// BoardDAOSpring 의 insertBoard() 메소드를 연속으로 두 번 호출한다.
		// 첫 번째 입력은 성공하지만
		// BOARD 테이블에 SEQ 컬럼이 기본키로 지정되어 있으므로
		// 두 번째 입력에서 예외가 발생한다.
		// 하지만 트랜잭션은 메소드 단위로 관리되므로 발생한 예외로 인해
		// BoardServiceImpl 클래스의 insertBoard() 메소드의 작업 결과는 모두 Rollback 처리된다.
		boardDAO.insertBoard(vo); // 100번 등록 성공
		boardDAO.insertBoard(vo); // Exception 발생
	}

~생략~
```

BoardServiceImpl 에서 BoardDAOSpring 객체의 insertBoard() 메소드를 호출하므로 BoardDAOSpring 의 insertBoard() 메소드와 SQL 구문을 다음처럼 수정한다.

```java
package com.springbook.biz.board.impl;

import java.util.List;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
import org.springframework.stereotype.Repository;

import com.springbook.biz.board.BoardVO;

// DAO(Data Access Object)
@Repository
public class BoardDAOSpring{
	@Autowired
	private JdbcTemplate jdbcTemplate;
	
	// SQL 명령어들
	private final String BOARD_INSERT = "insert into board(seq, title, writer, content) values(?, ?, ?, ?)";
	private final String BOARD_UPDATE = "update board set title=?, content=? where seq=?";
	private final String BOARD_DELETE = "delete board where seq=?";
	private final String BOARD_GET = "select * from board where seq=?";
	private final String BOARD_LIST = "select * from board order by seq desc";

//	@Autowired
//	public void setSuperDataSource(DataSource dataSource) {
//		super.setDataSource(dataSource);
//	}
	
	// CRUD 기능의 메소드 구현
	// 글 등록
	public void insertBoard(BoardVO vo) {
		System.out.println("===> Spring JDBC insertBoard() 기능 처리");
		jdbcTemplate.update(BOARD_INSERT, vo.getSeq(), vo.getTitle(), vo.getWriter(), vo.getContent());
	}

/*
SEQ 컬럼을 자동 증가하도록 작성한 SQL을 수정하여
사용자가 입력한 100번 글이 INSERT 되도록 수정했다.
~생략~
*/
```

```java
package com.springbook.biz.board;

import java.util.List;

import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.GenericXmlApplicationContext;

public class BoardServiceClient {

	public static void main(String[] args) {

		// 1. Spring 컨테이너 구동
		AbstractApplicationContext container = new GenericXmlApplicationContext("applicationContext.xml");
		
		// 2. Spring 컨테이너로부터 BoardServiceImpl 객체를 Lookup 한다.
		BoardService boardService = (BoardService)container.getBean("boardService");
		
		// 3. 글 등록 기능 테스트
		BoardVO vo = new BoardVO();
			// 사용자가 입력한 100번 글이 INSERT 되도록 수정
			vo.setSeq(100);
	    vo.setTitle("임시 제목");
	    vo.setWriter("홍길동");
	    vo.setContent("임시 내용..............");
	    boardService.insertBoard(vo);
	        
	    // 4. 글 목록 검색 기능 테스트
	    List<BoardVO> boardList = boardService.getBoardList(vo);
	    for (BoardVO board : boardList) {
		    System.out.println("---> " + board.toString());
	    }
	        
	   // 5. Spring 컨테이너 종료
	   container.close();
	}
}
```

실행 후 다음과 같은 에러 메시지 확인할 수 있다.

![Untitled 3](https://user-images.githubusercontent.com/77134124/105853967-9c787e00-6029-11eb-8b7b-926bb1083e06.png)

BoardServiceClient 클래스의 insertBoard() 메소드 호출 부분을 주석 처리하고 글 목록 출력만 실행해보면,

![Untitled 4](https://user-images.githubusercontent.com/77134124/105853973-9d111480-6029-11eb-8777-90829aa55c9c.png)

다음과 같이 글 목록에 100번 글이 입력되지 않음을 알 수 있다.

![Untitled 5](https://user-images.githubusercontent.com/77134124/105853979-9da9ab00-6029-11eb-8512-333139cf1436.png)
